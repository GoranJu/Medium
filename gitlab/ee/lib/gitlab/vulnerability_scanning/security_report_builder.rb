# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class SecurityReportBuilder
      include Gitlab::Utils::StrongMemoize
      include Gitlab::VulnerabilityScanning::AdvisoryUtils

      SECURITY_REPORT_VERSION = "0.0.0"
      DEPENDENCY_SCANNING_NAMESPACE = 'gitlab:dependency_scanning'

      def initialize(project:, pipeline:, sbom_report:)
        @project = project
        @pipeline = pipeline
        @sbom_report = sbom_report
        @report = ::Gitlab::Ci::Reports::Security::Report.new(source_type, pipeline, Time.zone.now)
        report.version = SECURITY_REPORT_VERSION
        report.add_scanner(scanner)
      end

      def execute
        return unless should_execute?

        validate!

        return report if report.errored?

        scan_sbom_report_occurrences

        report
      end
      strong_memoize_attr :execute # This is an expensive method to call, so we memoize it.

      private

      attr_reader :sbom_report, :project, :pipeline, :report

      def scanner
        VulnerabilityScanning::SecurityScanner.fabricate
      end
      strong_memoize_attr :scanner

      def should_execute?
        sbom_report_valid? && supported_source_type?
      end

      def sbom_report_valid?
        sbom_report.valid? && source_type.present?
      end

      def supported_source_type?
        source_type == :dependency_scanning
      end

      def source_type
        sbom_report.source&.source_type
      end

      def validate!
        add_missing_properties_error unless supported_dependency_scanning_sbom?
      end

      def supported_dependency_scanning_sbom?
        sbom_report.source&.input_file_path.present? || sbom_report.source&.source_file_path.present?
      end

      def add_missing_properties_error
        report.add_error('MissingPropertiesError', missing_properties_error)
      end

      def missing_properties_error
        "Missing required #{DEPENDENCY_SCANNING_NAMESPACE} CycloneDX properties"
      end

      def scan_sbom_report_occurrences
        sbom_report.components.each_slice(::Security::IngestionConstants::COMPONENTS_BATCH_SIZE) do |occurrence_batch|
          affected_packages(occurrence_batch).each_batch do |affected_package_batch|
            affected_package_batch.each do |affected_package|
              occurrence_batch.each do |occurrence|
                next unless affected_package.package_name == occurrence.name

                next unless affected_occurrence?(occurrence, sbom_report.source, affected_package)

                advisory_data_object = Gitlab::VulnerabilityScanning::Advisory.from_affected_package(
                  affected_package: affected_package, advisory: affected_package.advisory)

                finding = build_finding(advisory_data_object, occurrence, affected_package, sbom_report.source)

                next unless finding

                report.add_finding(finding)
                finding.identifiers.each { |ident| report.add_identifier(ident) }
              end
            end
          end
        end
      end

      def affected_packages(occurrence_batch)
        ::PackageMetadata::AffectedPackage.for_occurrences(occurrence_batch).with_advisory
      end

      def affected_occurrence?(occurrence, source, affected_package)
        advisory = affected_package.advisory
        occurrence_is_affected?(
          xid: advisory.advisory_xid,
          purl_type: affected_package.purl_type,
          range: affected_package.affected_range,
          version: occurrence.version,
          distro: affected_package.distro_version,
          source: source,
          project_id: pipeline.project_id,
          source_xid: advisory.source_xid
        )
      rescue SemverDialects::Error
        false
      end

      def build_finding(advisory_data_object, affected_occurrence, affected_package, source)
        ::Security::VulnerabilityScanning::BuildFindingMapService
          .execute(
            advisory: advisory_data_object,
            affected_component: affected_occurrence,
            source: source,
            pipeline: pipeline,
            project: project,
            purl_type: affected_package.purl_type,
            scanner: scanner
          )&.report_finding
      end
    end
  end
end
