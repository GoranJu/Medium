# frozen_string_literal: true

require 'spec_helper'
require_relative '../../completions/resolve_vulnerability/shared_examples'

RSpec.describe Gitlab::Llm::AiGateway::Completions::ResolveVulnerability, feature_category: :vulnerability_management do
  let_it_be(:user) { create(:user) }
  let_it_be(:user2) { create(:user) }
  let(:prompt_class) { Gitlab::Llm::Templates::Vulnerabilities::ResolveVulnerability }
  let(:merge_request_service) { ::MergeRequests::CreateFromVulnerabilityDataService }
  let(:merge_request) { create(:merge_request, :simple, source_project: project) }
  let(:mr_url) { Gitlab::Routing.url_helpers.project_merge_request_url(project, merge_request) }
  let(:finding_location_file) { 'main.c' }
  let(:changed_code) { "somecode\nexecute" }
  let(:content) { "```\n#{changed_code}\n``` and a ```\nsecond code block\n```" }

  let_it_be(:source_code) { "#include <stdio.h>\n\nint main() { printf(\"hello, world!\"); }" }
  let_it_be(:project) do
    create(:project, :custom_repo, files: { 'main.c' => source_code }, developers: [user, user2])
  end

  let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

  let(:prompt_message) do
    build(:ai_message, :resolve_vulnerability, user: user, resource: vulnerability, request_id: 'uuid')
  end

  let(:options) { {} }

  let(:logger) { instance_double(Gitlab::Llm::Logger) }

  let(:tracking_context) { { request_id: "uuid", action: :resolve_vulnerability } }
  let(:code_patch) { "<old_code>printf(\"hello, world!\");</old_code><new_code>\n#{changed_code}</new_code>" }
  let(:is_false_positive) { "false" }

  let(:response_body) do
    <<~CONTENT
      <analysis>
      analysis</analysis>
      <fixed_code>
      #{code_patch}</fixed_code>
      <is_false_positive>
      #{is_false_positive}</is_false_positive>
      <summary>
      some summary</summary>
    CONTENT
  end

  let(:description_options) { { analysis_data: "analysis", summary_data: "some summary", vulnerable_mr: nil } }

  let(:example_response) { instance_double(HTTParty::Response, body: response_body.to_json, success?: true) }

  subject(:resolve) { described_class.new(prompt_message, prompt_class, options) }

  def allow_llm_client_to_raise_error(error)
    allow_next_instance_of(::Gitlab::Llm::AiGateway::Client) do |client|
      allow(client).to receive(:complete).and_raise(error)
    end
  end

  def allow_llm_client_to_return_message(response)
    identifier_names = vulnerability.finding.identifier_names.join("\n* ")

    expect_next_instance_of(Gitlab::Llm::AiGateway::Client) do |client|
      expect(client).to receive(:complete).with(
        url: "#{Gitlab::AiGateway.url}/v1/prompts/resolve_vulnerability",
        body: { 'inputs' => {
          filename: finding_location_file,
          identifiers: "<report_identifiers>\n * #{identifier_names}\n</report_identifiers>",
          name: vulnerability.title,
          source_code: source_code,
          vulnerability_description: vulnerability.description,
          vulnerable_code: source_code
        } }
      ).and_return(response)
    end
  end

  describe '#execute' do
    it_behaves_like "a resolve vulnerability completion"
  end
end
