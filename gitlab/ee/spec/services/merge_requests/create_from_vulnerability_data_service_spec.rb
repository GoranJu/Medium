# frozen_string_literal: true

require 'spec_helper'

RSpec.describe MergeRequests::CreateFromVulnerabilityDataService, '#execute', feature_category: :vulnerability_management do
  let_it_be(:source_code) do
    <<~SOURCE
      #include <stdio.h>

      int main(int argc, char *argv[])
      {
        char buf[8];
        memcpy(&buf, "123456789");
        printf("hello, world!");
      }
    SOURCE
  end

  let_it_be(:expected_source_branch) { 'remediate/authentication-bypass-via-incorrect-dom-traversal-and-canonical' }

  let(:service) { described_class.new(project, vulnerability, user, params) }
  let(:result) { service.execute }

  let_it_be(:remediations_folder) { Rails.root.join('ee/spec/fixtures/security_reports/remediations') }
  let_it_be(:remediation_patch_content) { File.read(File.join(remediations_folder, "remediation.patch")) }
  let(:remediation_patch_tempfile) do
    Tempfile.new.tap do |f|
      f.write(Base64.encode64(remediation_patch_content))
      f.rewind
    end
  end

  let(:diff) do
    Base64.encode64(remediation_patch_content)
  end

  let_it_be(:group)   { create(:group) }
  let_it_be(:user)    { create(:user, developer_of: group) }
  let_it_be(:project) do
    create(:project, :custom_repo, namespace: group, files: {
      'yarn.lock' => File.read(File.join(remediations_folder, "yarn.lock")),
      'src/main.c' => source_code
    })
  end

  let(:dependency_scanning_finding_description) do
    {
      description: "Some XML DOM traversal and canonicalization APIs may be inconsistent in handling of comments within XML nodes. Incorrect use of these APIs by some SAML libraries results in incorrect parsing of the inner text of XML nodes such that any inner text after the comment is lost prior to cryptographically signing the SAML message. Text after the comment therefore has no impact on the signature on the SAML message.\n\nA remote attacker can modify SAML content for a SAML service provider without invalidating the cryptographic signature, which may allow attackers to bypass primary authentication for the affected SAML service provider."
    }
  end

  let(:dependency_scanning_finding_params) do
    {
      project: project,
      name: "Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js",
      cve: "yarn.lock:saml2-js:gemnasium:9952e574-7b5b-46fa-a270-aeb694198a98",
      solution: "Upgrade to fixed version.",
      location: {
        file: "yarn.lock",
        dependency: {
          package: {
            name: "saml2-js"
          },
          version: "1.5.0"
        }
      },
      project_fingerprint: "fa6f5b6c5d240b834ac5e901dc69f9484cef89ec"
    }.merge(dependency_scanning_finding_description)
  end

  let(:dependency_scanning_finding) do
    finding = create(:vulnerabilities_finding,
      :dependency_scanning, :with_remediation,
      dependency_scanning_finding_params
    )
    finding.remediations = Array.new(1) { create(:vulnerabilities_remediation, summary: "Upgrade saml2-js", file: remediation_patch_tempfile) }

    finding
  end

  let(:dependency_scanning_identifiers) do
    dependency_scanning_finding.identifiers = [
      create(:vulnerabilities_identifier,
        external_type: "gemnasium",
        name: "Gemnasium-9952e574-7b5b-46fa-a270-aeb694198a98",
        external_id: "9952e574-7b5b-46fa-a270-aeb694198a98",
        url: "https://deps.sec.gitlab.com/packages/npm/saml2-js/versions/1.5.0/advisories"
      ),
      create(:vulnerabilities_identifier,
        external_type: "cve",
        name: "CVE-2017-11429",
        external_id: "CVE-2017-11429",
        url: "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11429"
      )
    ]
  end

  let(:dependency_scanning_links) do
    dependency_scanning_finding.finding_links = [
      create(:finding_link, finding: dependency_scanning_finding,
        url: "https://github.com/Clever/saml2/commit/3546cb61fd541f219abda364c5b919633609ef3d#diff-af730f9f738de1c9ad87596df3f6de84R279",
        name: nil
      ),
      create(:finding_link, finding: dependency_scanning_finding,
        url: "https://github.com/Clever/saml2/issues/127",
        name: nil
      ),
      create(:finding_link, finding: dependency_scanning_finding,
        url: "https://www.kb.cert.org/vuls/id/475445",
        name: nil
      )
    ]
  end

  let(:vulnerability) do
    create(:vulnerability,
      findings: [dependency_scanning_finding],
      severity: "unknown"
    )
  end

  let(:params) { {} }

  let_it_be(:summary_data) do
    <<~SUMMARY
      1. The reported vulnerability is a buffer overflow in the main() function, where a 9-byte string is copied into an 8-byte buffer.

      2. The fix addresses this issue by:

      - Increasing the buffer size to 10 bytes to accommodate the 9-byte string plus a null terminator.
      - Changing memcpy(&buf, "123456789") to memcpy(buf, "123456789", 9).

      3. These changes ensure that:

      - The buffer is large enough to hold the string.
      - The correct number of bytes (9) is copied.
      - The &amp; operator is removed from buf, as it's unnecessary and incorrect when used with memcpy().

      This fix prevents buffer overflow by ensuring that the destination buffer is large enough to hold the source data. It maintains the original functionality while adhering to secure coding practices.

      Additional recommendations:

      - Consider using strncpy() or snprintf() for string operations, as they provide more safety features.
      - Always check the return value of memory operations for error handling.
      - If the string length is known at compile-time, consider using sizeof() for buffer allocation to prevent manual size miscalculations.

      char buf[sizeof("123456789")];
      strncpy(buf, "123456789", sizeof(buf));
      buf[sizeof(buf) - 1] = '\\0'  // Ensure null-termination

      This approach would further improve the code's safety and maintainability.
    SUMMARY
  end

  let_it_be(:analysis_data) do
    <<~ANALYSIS
      The vulnerability report lacks specific details about the type of vulnerability, making it challenging to directly correlate with the provided code. However, upon examining the source code, a clear buffer overflow vulnerability is present.
      The vulnerable code section is:

      char buf[8];
      memcpy(&buf, "123456789");

      This code creates a buffer buf of size 8 bytes, but then attempts to copy 9 bytes (the string "123456789") into it using memcpy(). This results in a buffer overflow, which can lead to memory corruption, crashes, or even arbitrary code execution in some cases.
      The vulnerability falls under the category of CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer.
      This is a genuine security concern as buffer overflows can be exploited by attackers to manipulate program behavior or execute malicious code.
    ANALYSIS
  end

  before do
    dependency_scanning_identifiers
    dependency_scanning_links
  end

  shared_examples 'a created merge_request' do
    it 'creates the merge_request with the given params' do
      expect(result[:status]).to eq(:success)
      merge_request = result[:merge_request]
      expect(merge_request).to be_persisted
      expect(merge_request.project).to eq(project)
      expect(merge_request.author).to eq(user)
      expect(merge_request.title).to eq(expected_title)
      expect(CGI.unescapeHTML(merge_request.description)).to eq(expected_description)
      expect(merge_request.target_branch).to eq(project.default_branch)
      expect(merge_request.source_branch).to start_with(expected_source_branch)
    end
  end

  context 'when user does not have permission to create merge_request' do
    before do
      allow_any_instance_of(described_class).to receive(:can?).with(user, :create_merge_request_in, project).and_return(false)
      allow_any_instance_of(described_class).to receive(:can?).with(user, :create_merge_request_from, project).and_return(false)
    end

    it 'returns expected error' do
      expect(result[:status]).to eq(:error)
      expect(result[:message]).to eq("User is not permitted to create merge request")
    end
  end

  context 'when merge_requests are disabled on project' do
    let(:project) { create(:project, namespace: group, merge_requests_access_level: ProjectFeature::DISABLED) }

    it 'returns expected error' do
      expect(result[:status]).to eq(:error)
      expect(result[:message]).to eq("User is not permitted to create merge request")
    end
  end

  context 'when params are valid' do
    context 'when category is dependency scanning' do
      context 'when a description is present' do
        let(:expected_title) { 'Resolve vulnerability: Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js' }
        let(:expected_description) do
          <<~DESC.chomp
            ### Description:

            Some XML DOM traversal and canonicalization APIs may be inconsistent in handling of comments within XML nodes. Incorrect use of these APIs by some SAML libraries results in incorrect parsing of the inner text of XML nodes such that any inner text after the comment is lost prior to cryptographically signing the SAML message. Text after the comment therefore has no impact on the signature on the SAML message.\n\nA remote attacker can modify SAML content for a SAML service provider without invalidating the cryptographic signature, which may allow attackers to bypass primary authentication for the affected SAML service provider.

            * Severity: unknown
            * Location: [yarn.lock](yarn.lock)

            ### Solution:

            Upgrade to fixed version.

            ### Identifiers:

            * [Gemnasium-9952e574-7b5b-46fa-a270-aeb694198a98](https://deps.sec.gitlab.com/packages/npm/saml2-js/versions/1.5.0/advisories)
            * [CVE-2017-11429](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11429)

            ### Links:

            * https://github.com/Clever/saml2/commit/3546cb61fd541f219abda364c5b919633609ef3d#diff-af730f9f738de1c9ad87596df3f6de84R279
            * https://github.com/Clever/saml2/issues/127
            * https://www.kb.cert.org/vuls/id/475445
          DESC
        end

        it_behaves_like 'a created merge_request'

        it 'creates a commit without skipping a pipeline' do
          expect(Commits::CommitPatchService).to receive(:new).with(
            project,
            user,
            a_hash_including(patches: [a_string_matching(/Subject: Fix Vulnerability - #{vulnerability.title}\n/)])
          ).and_call_original

          expect(result[:status]).to eq(:success)
        end
      end

      # This test is a bit finicky as findings source their information from both their table columns
      # or default to pulling it from the raw_metadata which is deprecated.
      context 'when a description, links and idenfitifers are NOT present' do
        let(:dependency_scanning_finding_description) { { description: "" } }
        let(:expected_description) do
          <<~DESC.chomp
            ### Description:

            Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js

            * Severity: unknown
            * Location: [yarn.lock](yarn.lock)

            ### Solution:

            Upgrade to fixed version.
          DESC
        end

        let(:expected_title) { 'Resolve vulnerability: Authentication bypass via incorrect DOM traversal and canonicalization in saml2-js' }
        let(:dependency_scanning_links) { dependency_scanning_finding.finding_links = [] }
        let(:dependency_scanning_identifiers) { dependency_scanning_finding.identifiers = [] }

        before do
          metadata = dependency_scanning_finding.metadata
          metadata.delete('description')
          metadata['links'] = ""
          dependency_scanning_finding.raw_metadata = metadata.to_json
        end

        it_behaves_like 'a created merge_request'
      end
    end
  end

  context 'when params are invalid' do
    context 'when remediations are missing' do
      let(:dependency_scanning_finding) do
        create(:vulnerabilities_finding,
          :dependency_scanning,
          dependency_scanning_finding_params
        )
      end

      it 'return expected error' do
        expect(result[:status]).to eq(:error)
        expect(result[:message]).to eq("No remediations available for merge request")
      end
    end
  end

  context 'when implementing a LLM remediation' do
    let(:sast_finding) do
      finding = create(:vulnerabilities_finding,
        :sast,
        project: project,
        name: "Long numbers in C code",
        description: "Long numbers in C code are bad, use shorter number",
        location: {
          'file' => 'src/main.c',
          'start_line' => 6,
          'end_line' => 6
        }
      )

      finding.metadata[:title] = "Long numbers in C code"

      finding
    end

    let(:llm_patch) { "  memcpy(&buf, \"1\");\n" }
    let(:vulnerability) { create(:vulnerability, findings: [sast_finding]) }

    context 'when params are invalid' do
      context 'when no llm_patch is given' do
        it 'return expected error' do
          expect(result[:status]).to eq(:error)
          expect(result[:message]).to eq("No remediations available for merge request")
        end
      end
    end

    context 'when params are valid' do
      let(:params) { { llm_patch: llm_patch, description_options: { analysis_data: analysis_data, summary_data: summary_data } } }

      let(:expected_title) { 'Resolve vulnerability: Long numbers in C code' }
      let(:expected_source_branch) { 'remediate/long-numbers-in-c-code-' }
      let(:expected_description) do
        <<~DESC.chomp
          MR created from vulnerability: [#{vulnerability.title}](#{vulnerability_url(vulnerability)})

          ## AI GENERATED FIX
          The suggested code changes were generated by GitLab Duo Vulnerability Resolution, an AI feature. **Use this feature with caution.** Before you run a pipeline or apply the code changes, carefully review and test them, to ensure that they solve the vulnerability.

          The large language model that generated the suggested code changes was provided with the entire file that contains the vulnerable lines of code. It is not aware of any functionality outside of this context.

          Please see [our documentation](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/#vulnerability-resolution) for more information about this feature and leave feedback in this [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/476553).

          ### Description:

          Long numbers in C code are bad, use shorter number

          * Severity: high
          * Location: [src/main.c:6](src/main.c:6)

          ### Analysis:
          The vulnerability report lacks specific details about the type of vulnerability, making it challenging to directly correlate with the provided code. However, upon examining the source code, a clear buffer overflow vulnerability is present.
          The vulnerable code section is:

          char buf[8];
          memcpy(&buf, "123456789");

          This code creates a buffer buf of size 8 bytes, but then attempts to copy 9 bytes (the string "123456789") into it using memcpy(). This results in a buffer overflow, which can lead to memory corruption, crashes, or even arbitrary code execution in some cases.
          The vulnerability falls under the category of CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer.
          This is a genuine security concern as buffer overflows can be exploited by attackers to manipulate program behavior or execute malicious code.

          ### Summary:
          1. The reported vulnerability is a buffer overflow in the main() function, where a 9-byte string is copied into an 8-byte buffer.

          2. The fix addresses this issue by:

          - Increasing the buffer size to 10 bytes to accommodate the 9-byte string plus a null terminator.
          - Changing memcpy(&buf, "123456789") to memcpy(buf, "123456789", 9).

          3. These changes ensure that:

          - The buffer is large enough to hold the string.
          - The correct number of bytes (9) is copied.
          - The & operator is removed from buf, as it's unnecessary and incorrect when used with memcpy().

          This fix prevents buffer overflow by ensuring that the destination buffer is large enough to hold the source data. It maintains the original functionality while adhering to secure coding practices.

          Additional recommendations:

          - Consider using strncpy() or snprintf() for string operations, as they provide more safety features.
          - Always check the return value of memory operations for error handling.
          - If the string length is known at compile-time, consider using sizeof() for buffer allocation to prevent manual size miscalculations.

          char buf[sizeof("123456789")];
          strncpy(buf, "123456789", sizeof(buf));
          buf[sizeof(buf) - 1] = '\\0'  // Ensure null-termination

          This approach would further improve the code's safety and maintainability.

          ### Solution:

          GCM mode introduces an HMAC into the resulting encrypted data, providing integrity of the result.


          ### Links:

          * [Cipher does not check for integrity first?](https://crypto.stackexchange.com/questions/31428/pbewithmd5anddes-cipher-does-not-check-for-integrity-first)
        DESC
      end

      it_behaves_like 'a created merge_request'

      it 'successfully creates a functional diff and patch from the LLM patch' do
        diff = <<~HEREDOC
          diff --git a/src/main.c b/src/main.c
          --- a/src/main.c
          +++ b/src/main.c
          @@ -4,5 +4,5 @@
           {
             char buf[8];
          -  memcpy(&buf, "123456789");
          +  memcpy(&buf, "1");
             printf("hello, world!");
           }
        HEREDOC

        expect(service).to receive(:render_template).with(
          file: 'vulnerabilities/remediation',
          formats: :patch,
          locals: hash_including(
            diff: diff
          )
        ).and_call_original
        expect(service).to receive(:render_template).with(
          file: 'vulnerabilities/merge_request_description',
          formats: :md,
          locals: instance_of(Hash)
        ).and_call_original
        expect(Commits::CommitPatchService).to receive(:new).with(
          project,
          user,
          a_hash_including(patches: [a_string_matching(/Subject: Fix Vulnerability - #{vulnerability.title} \[ci skip\]\n/)])
        ).and_call_original

        expect(result[:status]).to eq(:success)
      end

      context 'when a vulnerable MR is included in the description options' do
        let_it_be(:vulnerable_mr) { create(:merge_request, :simple) }

        let(:params) { super().tap { |p| p[:description_options][:vulnerable_mr] = vulnerable_mr } }

        it 'points back to the vulnerable MR in the description\'s first line' do
          actual_description = CGI.unescapeHTML(result[:merge_request].description)
          expected_pattern = %r{^Vulnerability finding detected in merge request: http.*?/merge_requests/#{vulnerable_mr.iid}\+s$}

          expect(actual_description.lines.first.strip).to match(expected_pattern)
        end
      end

      context 'with new response structure' do
        let(:llm_patch) { '<old_code>  memcpy(&buf, "123456789");</old_code><new_code>  memcpy(&buf, "1");</new_code>' }

        it 'successfully creates a functional diff and patch from the LLM patch' do
          diff = <<~HEREDOC
            diff --git a/src/main.c b/src/main.c
            --- a/src/main.c
            +++ b/src/main.c
            @@ -4,5 +4,6 @@
             {
               char buf[8];
            -  memcpy(&buf, "123456789");
            +  memcpy(&buf, "1");
               printf("hello, world!");
             }
          HEREDOC

          expect(service).to receive(:render_template).with(
            file: 'vulnerabilities/remediation',
            formats: :patch,
            locals: hash_including(
              diff: "#{diff}+\n"
            )
          ).and_call_original
          expect(service).to receive(:render_template).with(
            file: 'vulnerabilities/merge_request_description',
            formats: :md,
            locals: instance_of(Hash)
          ).and_call_original

          expect(result[:status]).to eq(:success)
        end

        context 'with more than one change' do
          let(:llm_patch) do
            '<old_code>  memcpy(&buf, "123456789");</old_code><new_code>  memcpy(&buf, "1");</new_code><old_code>  printf("hello, world!");</old_code><new_code>  printf("hello, world of tests!");</new_code>'
          end

          it 'successfully creates a functional diff and patch from the LLM patch' do
            diff = <<~HEREDOC
              diff --git a/src/main.c b/src/main.c
              --- a/src/main.c
              +++ b/src/main.c
              @@ -4,5 +4,6 @@
               {
                 char buf[8];
              -  memcpy(&buf, "123456789");
              -  printf("hello, world!");
              +  memcpy(&buf, "1");
              +  printf("hello, world of tests!");
               }
            HEREDOC

            expect(service).to receive(:render_template).with(
              file: 'vulnerabilities/remediation',
              formats: :patch,
              locals: hash_including(
                diff: "#{diff}+\n"
              )
            ).and_call_original
            expect(service).to receive(:render_template).with(
              file: 'vulnerabilities/merge_request_description',
              formats: :md,
              locals: instance_of(Hash)
            ).and_call_original

            expect(result[:status]).to eq(:success)
          end

          context 'with malformed response' do
            let(:llm_patch) do
              '<old_code>  memcpy(&buf, "123456789");</old_code><new_code>  memcpy(&buf, "1");</old_code>'
            end

            it 'returns an error' do
              expect(result[:status]).to eq(:error)
              expect(result[:message]).to eq("Response unreadable")
              expect(result[:unreadable_response]).to eq(true)
            end
          end

          context 'when patch cannot get applied' do
            it 'returns an error' do
              expect(Commits::CommitPatchService).to receive_message_chain(:new, :execute).and_return({ status: :error })

              expect(result[:status]).to eq(:error)
              expect(result[:message]).to eq("Unable to apply patch")
            end
          end
        end

        context 'when extra newlines are returned from the LLM' do
          let(:llm_patch) { "<old_code>\n  memcpy(&buf, \"123456789\");\n\n</old_code><new_code>\n  memcpy(&buf, \"1\");\n</new_code>" }

          it 'successfully creates a functional diff and patch from the LLM patch' do
            diff = <<~HEREDOC
              diff --git a/src/main.c b/src/main.c
              --- a/src/main.c
              +++ b/src/main.c
              @@ -4,5 +4,6 @@
               {
                 char buf[8];
              -  memcpy(&buf, "123456789");
              +  memcpy(&buf, "1");
                 printf("hello, world!");
               }
            HEREDOC

            expect(service).to receive(:render_template).with(
              file: 'vulnerabilities/remediation',
              formats: :patch,
              locals: hash_including(
                diff: "#{diff}+\n"
              )
            ).and_call_original
            expect(service).to receive(:render_template).with(
              file: 'vulnerabilities/merge_request_description',
              formats: :md,
              locals: instance_of(Hash)
            ).and_call_original

            expect(result[:status]).to eq(:success)
          end
        end
      end
    end
  end
end
