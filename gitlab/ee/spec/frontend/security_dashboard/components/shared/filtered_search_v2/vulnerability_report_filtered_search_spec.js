import { GlFilteredSearch } from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import VueRouter from 'vue-router';
import { isEqual } from 'lodash';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import waitForPromises from 'helpers/wait_for_promises';
import FilteredSearch from 'ee/security_dashboard/components/shared/filtered_search_v2/vulnerability_report_filtered_search.vue';
import StatusToken from 'ee/security_dashboard/components/shared/filtered_search_v2/tokens/status_token.vue';
import {
  STATUS_TOKEN_DEFINITION,
  SEVERITY_TOKEN_DEFINITION,
  PROJECT_TOKEN_DEFINITION,
} from 'ee/security_dashboard/components/shared/filtered_search_v2/tokens/constants';
import { FILTERS } from 'ee/security_dashboard/components/shared/vulnerability_report/constants';

Vue.use(VueRouter);
const router = new VueRouter();

describe('Vulnerability Report Filtered Search component', () => {
  let wrapper;

  const findFilteredSearchComponent = () => wrapper.findComponent(GlFilteredSearch);

  const createWrapper = async ({
    query = {},
    availableFilters = [FILTERS.STATUS, FILTERS.ACTIVITY, FILTERS.PROJECT],
    toolFilterType = 'scanner',
  } = {}) => {
    if (Object.keys(query).length > 0 && !isEqual(router.currentRoute.query, query)) {
      await router.replace({ query });
    }

    wrapper = shallowMountExtended(FilteredSearch, {
      propsData: {
        availableFilters,
      },
      provide: {
        scanners: [],
        toolFilterType,
      },
      router,
    });
  };

  describe('with empty query parameters', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('should mount the component with the correct config', () => {
      const filteredSearch = findFilteredSearchComponent();

      expect(filteredSearch.props('placeholder')).toEqual('Search or filter vulnerabilities...');
      expect(filteredSearch.props('termsAsTokens')).toBe(false);
      expect(filteredSearch.props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.defaultValues,
            operator: '||',
          },
        },
      ]);
    });

    it.each`
      name                     | availableFilters                      | availableTokens
      ${'status'}              | ${[FILTERS.STATUS]}                   | ${[STATUS_TOKEN_DEFINITION]}
      ${'status and severity'} | ${[FILTERS.STATUS, FILTERS.SEVERITY]} | ${[STATUS_TOKEN_DEFINITION, SEVERITY_TOKEN_DEFINITION]}
      ${'status and project'}  | ${[FILTERS.STATUS, FILTERS.PROJECT]}  | ${[STATUS_TOKEN_DEFINITION, PROJECT_TOKEN_DEFINITION]}
    `(
      `passes the expected available tokens for filters '$name'`,
      ({ availableFilters, availableTokens }) => {
        createWrapper({ availableFilters });

        expect(findFilteredSearchComponent().props('availableTokens')).toEqual(availableTokens);
      },
    );

    it('should emit empty filters on clear', () => {
      findFilteredSearchComponent().vm.$emit('clear');
      expect(wrapper.emitted('filters-changed')).toEqual([[{}]]);
    });
  });

  describe('with non-empty query parameters', () => {
    beforeEach(async () => {
      await createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.SEVERITY, FILTERS.PROJECT],
        query: { severity: 'MEDIUM,LOW', projectId: '5,10' },
      });
    });

    it('should pass route parameters to the tokens', () => {
      expect(findFilteredSearchComponent().props('value')).toEqual([
        {
          type: 'state',
          value: {
            data: StatusToken.defaultValues,
            operator: '||',
          },
        },
        {
          type: 'severity',
          value: {
            data: ['MEDIUM', 'LOW'],
            operator: '||',
          },
        },
        {
          type: 'projectId',
          value: {
            data: ['5', '10'],
            operator: '||',
          },
        },
      ]);
    });
  });

  describe('with incorrect available-filters', () => {
    beforeEach(async () => {
      await createWrapper({
        availableFilters: ['does-not-exist'],
        query: {},
      });
    });

    it('does not throw an error', () => {
      expect(wrapper.exists()).toBe(true);
    });
  });

  describe('route and filters logic', () => {
    const defaultRouterQuery = { status: 'detected' };

    beforeEach(async () => {
      await createWrapper({
        availableFilters: [FILTERS.STATUS, FILTERS.SEVERITY],
        query: defaultRouterQuery,
      });
    });

    describe('severity token', () => {
      it('should omit severity in the query when value is ALL', () => {
        findFilteredSearchComponent().vm.$emit('input', [{ severity: ['ALL'] }]);

        expect(router.currentRoute.query).toEqual({
          status: 'detected',
        });
      });

      it('should omit severity in the query when value is null', () => {
        findFilteredSearchComponent().vm.$emit('input', [{ severity: null }]);

        expect(router.currentRoute.query).toEqual({
          status: 'detected',
        });
      });

      it('should update severity value in the query when value is not empty', async () => {
        findFilteredSearchComponent().vm.$emit('input', [
          { type: 'severity', value: { data: ['MEDIUM', 'HIGH'] } },
        ]);

        // Wait for promises to pass under Vue 3.
        //
        // This isn't robust, but it seems like the least bad approach for now.
        // Ideally we'd wait explicitly for the navigation to be complete, but
        // that happens inside the implementation, so we can't await it in tests.
        //
        // - Adding router.beforeEach/afterEach hooks to set up a promise isn't
        //   sufficient. Even after afterEach is called, the navigation still
        //   isn't done.
        // - We could emit a new event in the implementation, e.g.,
        //   this.$router.push().then(() => { this.$emit('navigated') }), but
        //   that feels like a hack, as it'd just be for testing purposes.
        await waitForPromises();

        expect(router.currentRoute.query).toEqual({
          severity: 'MEDIUM,HIGH',
          state: 'ALL',
        });

        await nextTick();

        expect(wrapper.emitted('filters-changed')).toEqual([[{ severity: ['MEDIUM', 'HIGH'] }]]);
      });
    });

    describe('handleInput', () => {
      beforeEach(() => {
        createWrapper({
          query: { state: 'ALL' },
        });
      });

      // The filtered search component sends an input event when mounted, which
      // breaks our router logic so we ignore the first call
      it('should do nothing on the first call', async () => {
        findFilteredSearchComponent().vm.$emit('input', []);

        await waitForPromises();

        expect(router.currentRoute.query).toEqual({ state: 'ALL' });
        expect(wrapper.emitted('filters-changed')).toBeUndefined();
      });

      it('should update query and filters when input event is triggered', async () => {
        findFilteredSearchComponent().vm.$emit('input', [
          { type: 'state', value: { data: ['NEEDS_TRIAGE'] } },
          { type: 'severity', value: { data: ['MEDIUM', 'LOW'] } },
        ]);

        expect(wrapper.emitted('filters-changed')[0][0]).toEqual({
          state: ['NEEDS_TRIAGE'],
          dismissalReason: [], // This comes from the StateToken.transformFilters
          severity: ['MEDIUM', 'LOW'],
        });

        await waitForPromises();

        expect(router.currentRoute.query).toEqual({
          state: 'NEEDS_TRIAGE',
          severity: 'MEDIUM,LOW',
        });
      });

      it('should not emit any events when value.data is empty', async () => {
        findFilteredSearchComponent().vm.$emit('input', [
          { type: 'severity', value: { data: null } },
          { type: 'state', value: { data: null } },
        ]);

        expect(wrapper.emitted('filters-changed')).toBeUndefined();

        await waitForPromises();

        // Same as before
        expect(router.currentRoute.query).toEqual({ state: 'ALL' });
      });

      it('should add ALL to the query parameter for tokens with default values', async () => {
        findFilteredSearchComponent().vm.$emit('input', [
          { type: 'severity', value: { data: ['LOW'] } },
        ]);

        expect(wrapper.emitted('filters-changed')[0][0]).toEqual({
          severity: ['LOW'],
        });

        await waitForPromises();

        expect(router.currentRoute.query).toEqual({
          state: 'ALL',
          severity: 'LOW',
        });
      });
    });
  });
});
