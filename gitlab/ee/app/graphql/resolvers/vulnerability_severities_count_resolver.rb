# frozen_string_literal: true

module Resolvers
  class VulnerabilitySeveritiesCountResolver < VulnerabilitiesBaseResolver
    include Gitlab::Utils::StrongMemoize
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::VulnerabilitySeveritiesCountType, null: true
    authorize :read_security_resource
    authorizes_object!

    argument :project_id, [GraphQL::Types::ID],
      required: false,
      description: 'Filter vulnerabilities by project.'

    argument :report_type, [Types::VulnerabilityReportTypeEnum],
      required: false,
      description: 'Filter vulnerabilities by report type.'

    argument :severity, [Types::VulnerabilitySeverityEnum],
      required: false,
      description: 'Filter vulnerabilities by severity.'

    argument :state, [Types::VulnerabilityStateEnum],
      required: false,
      description: 'Filter vulnerabilities by state.'

    argument :owasp_top_ten, [Types::VulnerabilityOwaspTop10Enum],
      required: false,
      as: :owasp_top_10,
      description: 'Filter vulnerabilities by OWASP Top 10 category. Wildcard value "NONE" also supported ' \
                   'and it cannot be combined with other OWASP top 10 values.'

    argument :scanner, [GraphQL::Types::String],
      required: false,
      description: 'Filter vulnerabilities by scanner.'

    argument :scanner_id, [::Types::GlobalIDType[::Vulnerabilities::Scanner]],
      required: false,
      description: 'Filter vulnerabilities by scanner ID.'

    argument :has_issues, GraphQL::Types::Boolean,
      required: false,
      description: 'Filter vulnerabilities that do or do not have issues.'

    argument :has_resolution, GraphQL::Types::Boolean,
      required: false,
      description: 'Filter vulnerabilities that do or do not have a resolution.'

    argument :has_ai_resolution, GraphQL::Types::Boolean,
      required: false,
      experiment: { milestone: '17.5' },
      description: 'Filters vulnerabilities which can or can not be resolved by GitLab Duo Vulnerability Resolution. Requires the `vulnerability_report_vr_filter` feature flag to be enabled, otherwise the argument is ignored.'

    argument :image, [GraphQL::Types::String],
      required: false,
      description: "Filter vulnerabilities by location image. When this filter is present, "\
                   "the response only matches entries for a `reportType` "\
                   "that includes #{::Vulnerabilities::Finding::REPORT_TYPES_WITH_LOCATION_IMAGE.map { |type| "`#{type}`" }.join(', ')}."

    argument :cluster_agent_id, [::Types::GlobalIDType[::Clusters::Agent]],
      prepare: ->(ids, _) { ids.map(&:model_id) },
      required: false,
      description: "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` "\
                   "of `cluster_image_scanning` are only included with this filter."

    argument :has_merge_request, GraphQL::Types::Boolean,
      required: false,
      description: 'Filter vulnerabilities that do or do not have a merge request.'

    argument :dismissal_reason, [Types::Vulnerabilities::DismissalReasonEnum],
      required: false,
      description: "Filter by dismissal reason."

    argument :has_remediations, GraphQL::Types::Boolean,
      required: false,
      description: 'Filter vulnerabilities that do or do not have remediations.'

    argument :capped, GraphQL::Types::Boolean,
      default_value: false,
      required: false,
      description: 'Default value is false. When set to true, the count returned for each severity is capped at a maximum of 1001.'

    argument :identifier_name, GraphQL::Types::String,
      required: false,
      experiment: { milestone: '17.7' },
      description: 'Filter vulnerabilities by identifier name. Applicable on project ' \
                    'level when feature flag `vulnerability_identifier_name_filter` is ' \
                    'enabled. Applicable on group level when feature flag `vulnerability_filtering_by_identifier_group` is enabled. Ignored when applied on instance security' \
                    'dashboard queries.'

    def resolve(**args)
      return Vulnerability.none unless vulnerable

      validate_filters(args)

      args[:scanner_id] = resolve_gids(args[:scanner_id], ::Vulnerabilities::Scanner) if args[:scanner_id]

      if args[:capped].present?
        vulnerabilities(args).capped_count_by_severity
      else
        vulnerabilities(args).count_by_severity
      end
    end

    private

    def vulnerabilities(filters)
      filters.delete(:has_ai_resolution) unless resolve_with_duo_filtering_enabled?
      ::Security::VulnerabilityReadsFinder.new(vulnerable, filters).execute
    end

    def resolve_with_duo_filtering_enabled?
      actor = case vulnerable
              when ::InstanceSecurityDashboard
                current_user
              when Project
                vulnerable.group
              else
                vulnerable
              end

      Feature.enabled?(:vulnerability_report_vr_filter, actor)
    end
  end
end
