# frozen_string_literal: true

# Security::VulnerabilityReadsFinder
#
# Used to filter Vulnerability records for Vulnerabilities API from vulnerability_reads table
#
# Arguments:
#   vulnerable: any object that has a #vulnerabilities method that returns a collection of `Vulnerability`s
#   params: optional! a hash with one or more of the following:
#     project_id: if `vulnerable` includes multiple projects (like a Group), this filter will restrict
#                   the vulnerabilities returned to those in the group's projects that also match these IDs
#     include_archived_projects: defaulted to `false`. Determines if results will include vulnerabilities
#                                 associated with archived projects
#     image: only return vulnerabilities with these location images
#     report_type: only return vulnerabilities from these report types
#     severity: only return vulnerabilities with these severities
#     state: only return vulnerabilities in these states
#     scanner: only return vulnerabilities with these external_id
#     scanner_id: only return vulnerabilities with these scanner_ids
#     has_resolution: only return vulnerabilities that have resolution
#     has_ai_resolution: only return vulnerabilities that are eligible to be resolved by an LLM
#     has_issues: only return vulnerabilities that have issues linked
#     has_merge_request: only return vulnerabilities that have MR(s) linked
#     cluster_agent_id: only return vulnerabilities with these cluster_agent_ids
#     has_remediations: only return vulnerabilities that have remediations
#     before_severity: only return vulnerabilities with lower severity than given value if sorting is ascending,
#                      returns vulnerabilities with higher severity otherwise. Works only for groups.
#     after_severity: only return vulnerabilities with higher severity than given value if sorting is ascending,
#                     returns vulnerabilities with lower severity otherwise. Works only for groups.
#     sort: return vulnerabilities ordered by severity_asc or severity_desc

module Security
  class VulnerabilityReadsFinder
    include FinderMethods
    include Gitlab::Utils::StrongMemoize

    FILTER_NONE = 'none'

    def initialize(vulnerable, params = {})
      @params = params
      @vulnerable = vulnerable
      @vulnerability_reads = initial_relation
    end

    def execute
      use_unnested_filters
      filter_archived_projects
      filter_by_projects
      filter_by_image
      filter_by_report_types
      filter_by_severities
      filter_by_states_and_dismissal_reason
      filter_by_scanner_external_id
      filter_by_scanner_ids
      filter_by_resolution
      filter_by_ai_resolution
      filter_by_issues
      filter_by_has_merge_request
      filter_by_cluster_agent_id
      filter_by_has_remediations
      filter_by_owasp_top_10
      filter_by_identifier_name

      sort
    end

    private

    attr_reader :params, :vulnerable, :vulnerability_reads

    def initial_relation
      return Vulnerabilities::Read.by_group_using_nested_loop(vulnerable) if should_use_nested_loop?

      vulnerable.vulnerability_reads
    end

    def use_unnested_filters
      return unless use_unnested_filters?

      @vulnerability_reads = vulnerability_reads.use_unnested_filters
    end

    def use_unnested_filters?
      vulnerable.is_a?(Project) || vulnerable.is_a?(Group)
    end

    def filter_archived_projects
      return if params[:include_archived_projects] == true

      return unless vulnerable.is_a?(Group)

      @vulnerability_reads = vulnerability_reads.unarchived
    end

    def filter_by_projects
      return unless params[:project_id].present?

      return @vulnerability_reads = vulnerability_reads.by_projects(params[:project_id]) if vulnerability_is_a_group?

      @vulnerability_reads = vulnerability_reads.for_projects(params[:project_id])
    end

    def filter_by_report_types
      return unless report_types.present?

      @vulnerability_reads = vulnerability_reads.with_report_types(report_types)
    end

    def filter_by_severities
      return unless severities.present?

      @vulnerability_reads = vulnerability_reads.with_severities(severities)
    end

    def filter_by_states_and_dismissal_reason
      return unless states.present? || params[:dismissal_reason].present?

      @vulnerability_reads = if states.present? && params[:dismissal_reason].present?
                               vulnerability_reads
                                .with_states(states)
                                .or(
                                  vulnerability_reads
                                    .with_states("dismissed")
                                    .with_dismissal_reason(params[:dismissal_reason])
                                )
                             elsif states.present?
                               vulnerability_reads.with_states(states)
                             else
                               vulnerability_reads
                                 .with_states("dismissed")
                                 .with_dismissal_reason(params[:dismissal_reason])
                             end
    end

    def filter_by_owasp_top_10
      return unless params[:owasp_top_10].present?

      filter_value = filter_by_no_owasp_top_10? ? ::Vulnerabilities::Read::OWASP_TOP_10_DEFAULT : params[:owasp_top_10]

      @vulnerability_reads = vulnerability_reads.with_owasp_top_10(filter_value)
    end

    def filter_by_identifier_name
      return if params[:identifier_name].blank?

      return if vulnerable.is_a?(Group) && Feature.disabled?(:vulnerability_filtering_by_identifier_group, vulnerable,
        type: :beta)

      @vulnerability_reads = vulnerability_reads.with_identifier_name(params[:identifier_name])
    end

    def filter_by_scanner_ids
      return unless params[:scanner_id].present?

      @vulnerability_reads = vulnerability_reads.by_scanner_ids(params[:scanner_id])
    end

    def filter_by_scanner_external_id
      return unless params[:scanner].present?

      @vulnerability_reads = vulnerability_reads.with_scanner_external_ids(params[:scanner])
    end

    def filter_by_resolution
      return unless params[:has_resolution].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_resolution(params[:has_resolution])
    end

    def filter_by_ai_resolution
      return unless params[:has_ai_resolution].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_ai_resolution(params[:has_ai_resolution])
    end

    def filter_by_issues
      return unless params[:has_issues].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_issues(params[:has_issues])
    end

    def filter_by_has_merge_request
      return unless params[:has_merge_request].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_merge_request(params[:has_merge_request])
    end

    def filter_by_image
      return if vulnerable.is_a?(InstanceSecurityDashboard) || !params[:image].present?

      @vulnerability_reads = vulnerability_reads.with_container_image(params[:image])
    end

    def filter_by_cluster_agent_id
      return unless params[:cluster_agent_id].present?

      # TODO: One background migration to fill casted_cluster_agent_id migration is finished,
      # we can remove this. See: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/89915
      cluster_agent_ids_as_string = Array.wrap(params[:cluster_agent_id]).map(&:to_s)
      @vulnerability_reads = vulnerability_reads.with_cluster_agent_ids(cluster_agent_ids_as_string)
    end

    def filter_by_has_remediations
      return unless params[:has_remediations].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_remediations(params[:has_remediations])
    end

    def sort
      if vulnerability_is_a_group?
        @vulnerability_reads.order_by_params_and_traversal_ids(params[:sort])
      else
        @vulnerability_reads.order_by(params[:sort])
      end
    end

    def filter_by_no_owasp_top_10?
      params[:owasp_top_10].join.downcase == FILTER_NONE
    end

    def severities
      if backward_sorting?
        severities_for_backward_sorting
      else
        severities_for_forward_sorting
      end
    end
    strong_memoize_attr :severities

    def severities_for_backward_sorting
      if after_severity_value
        selected_severities.reject { |severity| severity > after_severity_value }
      elsif before_severity_value
        selected_severities.reject { |severity| severity < before_severity_value }
      else
        selected_severities
      end
    end

    def severities_for_forward_sorting
      if after_severity_value
        selected_severities.reject { |severity| severity < after_severity_value }
      elsif before_severity_value
        selected_severities.reject { |severity| severity > before_severity_value }
      else
        selected_severities
      end
    end

    def report_types
      return Vulnerability.report_types.keys if vulnerability_is_a_group? && params[:report_type].blank?

      params[:report_type]
    end
    strong_memoize_attr :report_types

    def states
      return Vulnerability.states.keys if vulnerability_is_a_group? && params[:state].blank?

      params[:state]
    end
    strong_memoize_attr :states

    def vulnerability_is_a_group?
      vulnerable.is_a?(Group)
    end
    strong_memoize_attr :vulnerability_is_a_group?

    def should_use_nested_loop?
      vulnerability_is_a_group? && params[:sort]&.starts_with?('detected')
    end

    # Returns corresponding integer values for selected severities.
    def selected_severities
      return Vulnerability.severities.values if vulnerability_is_a_group? && params[:severity].blank?

      Vulnerability.severities.slice(*params[:severity]).values
    end

    def after_severity_value
      @after_severity_value ||= Vulnerabilities::Read.severities[params[:after_severity]]
    end

    def before_severity_value
      @before_severity_value ||= Vulnerabilities::Read.severities[params[:before_severity]]
    end

    def backward_sorting?
      return false unless params[:sort]

      params[:sort].ends_with?('desc')
    end
  end
end
